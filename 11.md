谷粒商城实现





```
 PowerDesigner |   数据库设计工具    |             http://powerdesigner.de             |
```





前端实现



```
| thymeleaf |  模板引擎  | https://www.thymeleaf.org 
```







///



auth模块





针对session的cookie定制处理



  结合JWT



针对oauth 实现SSO



授权服务器

  springsec- 结合授权机制



clientid -

  得到具体的







 sso服务器 保存用户信息



sso请求器

  保存具体的token状态



用户申请

  client 

​    sso 中断

  验证是否符合

  



SSO‘



核心验证服务器



  保持全局会话】

   授予令牌

​    对局部服务器发生令牌进行检验



后续用户根据令牌进行检验

 存在过期时间





#### 1. 业务痛点：为什么需要定制 Cookie 规则？

Spring Session 默认的 Cookie 规则（如 Cookie 名称、生效域名等）可能不符合分布式业务场景的需求：

- 默认 Cookie 名称是 `SESSION`：如果系统中存在多个 Session 机制（如同时用 Spring Session 和其他框架的 Session），可能出现名称冲突；
- 默认生效域名是当前请求的域名（如 `user.gulimall.com`）：分布式系统通常有多个子域名（`user.gulimall.com`、`order.gulimall.com`、`pay.gulimall.com`），默认配置下，一个子域名下发的 Cookie 无法被其他子域名读取，导致「跨子域 Session 共享失效」（用户在 `user` 子域登录后，访问 `order` 子域仍需重新登录）。

#### 2. 这个 @Bean 的核心作用

通过 `@Bean` 注册一个定制化的 `CookieSerializer`，Spring Session 会使用它来「生成下发给客户端的 Cookie」，以及「解析客户端请求携带的 Cookie」，核心是定制 SessionID 的传递规则。





针对cookie伪造风险



XSS CRSF

```java
 serializer.setCookieMaxAge(3600); // Cookie 过期时间（1小时，与 Session 过期时间对齐）
    serializer.setSecure(true); // 仅 HTTPS 协议下传递 Cookie（生产环境必配，防止 Cookie 被劫持）
    serializer.setHttpOnly(true); // 禁止前端 JS 读取 Cookie（防止 XSS 攻击窃取 SessionID）
```







针对注册MVC的增强

[    default void addFormatters(FormatterRegistry registry) {
    }

```c
default void addInterceptors(InterceptorRegistry registry) {
}
// 实现拦截器

default void addResourceHandlers(ResourceHandlerRegistry registry) {
}

default void addCorsMappings(CorsRegistry registry) {
}]()
```



添加默认方法



```js
@FeignClient(value = "gulimall-member",fallback = MemberFallbackService.class)
public interface MemberFeignService {
    
    @Value("'你好'")
    String msg = "";
    
    @RequestMapping("member/member/register")
    R register(@RequestBody UserRegisterVo registerVo);


    @RequestMapping("member/member/login")
     R login(@RequestBody UserLoginVo loginVo);

    @RequestMapping("member/member/oauth2/login")
    R login(@RequestBody UserRespVO socialUser);
    
    
    default void printInfo(){
        System.out.println("info is printing");
    }
}
```



##### 问题原因：

1. **语法不支持**：`@Value` 是 Spring 用于「依赖注入」的注解，只能用在 **Spring 容器管理的 Bean 的字段 / 方法 / 构造器上**；而 Feign 接口本身不是 Bean（其实现类由 Feign 动态生成并交给 Spring 管理），直接在接口字段上用 `@Value` 完全无效。
2. **接口字段特性**：Java 接口中的字段默认是 `public static final`（常量），`@Value` 无法为常量注入值，最终 `msg` 的值还是空字符串 `""`，失去预期意义。





#### 远程 feign是否底层通过代理实现

1. **Feign 底层确实依赖动态代理**：默认使用 JDK 动态代理（基于接口），核心处理器是 `FeignInvocationHandler`，负责将接口方法映射为 HTTP 调用；
2. **`default` 方法不支持的根本原因**：Feign 代理只关注「无实现的抽象 HTTP 方法」，`default` 方法有默认实现，不在 Feign 的解析和拦截范围内，导致要么启动报错，要么调用无效；
3. **延伸：Feign 支持的方法类型**：只能是「带有 HTTP 注解（`@RequestMapping`/`@GetMapping` 等）的抽象方法」，且方法参数 / 返回值需符合 Feign 的序列化要求（如 `@RequestBody` 注解的参数会被序列化为请求体）。



针对动态代理实现机制



 使用Handler 代理处理机制



且在具体的invoke的 实现增强逻辑



 看是否会针对解析具体抽象方法



产生代理对象 注入ioc



---



针对springsession 集成



*3. 依赖 3：Cookie 与 SessionID 关联机制（跨域会话识别核心）

- **作用**：让认证中心能识别「同一个用户」的请求，核心是你之前配置的 `CookieSerializer`。

- 关键流程

  ：

  - 用户首次访问 `/login.html` 时，若未登录，`HttpSession` 会生成一个唯一的 `SessionID`（即 `GULISESSIONID`），通过 Cookie 下发给浏览器（Cookie 的域名是 `gulimall.com`，支持所有子域共享）；
  - 浏览器后续访问任何子域（如 `order.gulimall.com`）时，都会携带这个 Cookie，对应的服务就能通过 `SessionID` 从 Redis 中查询 Session 数据，判断用户是否已登录；
  - 依赖的核心组件：`DefaultCookieSerializer`（定制 Cookie 名称、域名、过期时间等）、浏览器的 Cookie 存储机制（遵循 HTTP Cookie 规范）。





----



## 登陆模块





针对登陆接口设计





 密码敏感度处理

```c
 返回实体暴露敏感字段（虽清空密码，但仍有风险）
问题表现：entity.setPassword("") 后返回 MemberEntity，该实体可能包含其他敏感字段（如身份证号、邮箱、地址等）。
业务影响：登录接口无需返回完整用户实体，过多敏感信息传输可能导致泄露（比如前端误展示、传输过程被劫持）。
```





关于加密机制的底层





1. **BCrypt 加密**：底层通过「自动加盐 + 自适应哈希」解决 “密码存储安全” 问题，语法层面无需关注盐值管理，是密码存储的最优解；



请求第三方机制-



 实现注册



```c
            //调用微博api接口获取用户信息
            String json = null;
            try {
                HttpResponse response = HttpUtils.doGet("https://api.weibo.com", "/2/users/show.json", "get", new HashMap<>(), query);
                json = EntityUtils.toString(response.getEntity());
            } catch (Exception e) {
                e.printStackTrace();
            }
            JSONObject jsonObject = JSON.parseObject(json);
            //获得昵称，性别，头像
            String name = jsonObject.getString("name");
            String gender = jsonObject.getString("gender");
            String profile_image_url = jsonObject.getString("profile_image_url");
```



关于使用社交登陆方式



![image-20251203111250777](../../AppData/Roaming/Typora/typora-user-images/image-20251203111250777.png)



在具体的实体类

 添加相关业务字段

‘’





针对JSON引用类型转化机制





```c
        MemberCouponsDTO memberCouponsDTO = r.getData(new TypeReference<MemberCouponsDTO>() {
        });
        

        return R.ok().put("memberEntity", member)
                .put("coupons", JSON.toJSONString(memberCouponsDTO.getCoupons()));
```



针对泛型集合

###### 2. 结论：序列化永远不需要 TypeReference

无论 `memberCouponsDTO.getCoupons()` 是「简单类型」（如 String、Integer）、「复杂对象」（如 CouponDTO）、「泛型集合」（如 List<CouponDTO>），序列化时都不需要 TypeReference—— 因为对象本身的运行时类型已经足够 FastJSON 完成转化。





需要使用

###### 1. 泛型擦除的问题（反序列化需要 TypeReference 的根源）

Java 在编译时会删除泛型的具体类型信息，仅保留原始类型。比如：

- 代码中写 `List<CouponDTO>`，编译后会变成 `List`（原始类型）；
- 当你从 JSON 字符串反序列化为 `List<CouponDTO>` 时，如果直接用 `JSON.parseObject(jsonStr, List.class)`，FastJSON 无法知道 `List` 里面的元素是 `CouponDTO`，只能反序列化为 `List<HashMap>`（默认将 JSON 对象转为 HashMap），导致后续强转 `List<CouponDTO>` 报错。

###### 2. 必须用 TypeReference 的场景：反序列化「复杂泛型类型」

当反序列化的目标类型是「包含泛型的复杂类型」（如 `List<T>`、`Map<K,V>`、`Result<T>`、`List<Map<String, Object>>` 等）时，必须用 TypeReference 来明确泛型的具体类型。



```java
);
```

#### 场景 2：反序列化泛型包装类（如你的 Result<MemberCouponsDTO>）

你的代码中这行就是典型场景：





```java
MemberCouponsDTO memberCouponsDTO = r.getData(new TypeReference<MemberCouponsDTO>() {});
```

假设 `r.getData()` 底层是从 JSON 字符串反序列化，`MemberCouponsDTO` 可能包含泛型字段（如 `private List<CouponDTO> coupons`），或者 `r` 本身是泛型响应类（如 `Result<T>`）—— 此时用 TypeReference 可以明确「泛型的具体类型」，避免反序列化时类型丢失。





##### 若不涉及泛型擦除机制



###### 3. 不需要用 TypeReference 的场景：反序列化「非泛型简单类型」

如果目标类型是「无泛型的简单对象」（如 `CouponDTO`、`MemberEntity` 等），直接用 `JSON.parseObject(jsonStr, 目标类.class)` 即可，无需 TypeReference：







```java
String couponJson = "{\"id\":1,\"name\":\"满100减20\"}";
// 无需TypeReference，直接用类.class
CouponDTO coupon = JSON.parseObject(couponJson, CouponDTO.class);
```



### 路基参数获取

```c
@GetMapping("/coupons/{memberId}")
public R getMemberCoupons(@PathVariable("memberId") String memberId) {
```



结合具体的实例展示



若为Long 具体路径如何请求



MVC的参数自动转换

**与 @RequestParam 的区别**：

若接口是`@RequestParam`（查询参数），格式为`/coupons?memberId=1001`，Long 类型的请求方式完全一致（参数值传纯数字即可），本质都是 SpringMVC 自动完成字符串→Long 的转换



#### MVC参数传入引用对象的形式



```
@PostMapping("/member/register")
public void register(@RequestBody MemberRegisterVo memberRegisterVo) {
```

SpringMVC 会默认按「表单提交 / 查询参数」的规则绑定：

- 它会去 URL 查询参数（如`/member/register?username=xxx&password=xxx`）或请求体（表单格式`username=xxx&password=xxx`）中，寻找与`MemberRegisterVo`字段名一致的「键值对」；
- 但如果前端传的是 JSON 格式（请求头`Content-Type: application/json`），请求体里是`{"username":"xxx","password":"xxx"}`这种字符串，SpringMVC 没有`@RequestBody`的指示，不会调用 JSON 解析器（如 Jackson）去解析这个字符串，只会把它当作普通文本，无法匹配对象的字段；
- 最终结果：`memberRegisterVo`对象会被实例化，但所有字段都是`null`（绑定失败）。



### 场景 1：表单提交（`application/x-www-form-urlencoded`）

- 前端请求头：`Content-Type: application/x-www-form-urlencoded`；
- 请求体：`username=zhangsan&password=123456`（键值对格式，不是 JSON）；
- 后端无`@RequestBody`：可以正常绑定`MemberRegisterVo`的`username`和`password`字段。

### 场景 2：查询参数（URL 拼接）

- 前端请求 URL：`/member/register?username=zhangsan&password=123456`；
- 后端无`@RequestBody`：也能正常绑定（SpringMVC 会从 URL 中提取参数匹配对象字段）。

##### mp错误

#### 1. `MemberEntity` 中 `getUid()` 方法不是 **非静态的实例方法**（或写法错误）

- 若 `getUid()` 是 `static` 方法：LambdaQueryWrapper 不支持静态方法引用（因为它需要通过实体类的**实例**来获取字段映射）；
- 若 `getUid()` 不存在：IDEA 会误将方法引用识别为 “静态上下文调用”，从而抛出该错误。

#### 2. MyBatis-Plus 版本或依赖问题

低版本的 MyBatis-Plus 对 Lambda 方法引用的支持可能存在 Bug，导致 IDE 误报该错误（即使方法是正确的实例方法）。







---



## 支付模块





针对seta事务配置i







针对JWT 进行拦截q



查看令牌是否有效



且查询具体数据库实现

 

```c
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String requestURI = request.getRequestURI();
        AntPathMatcher matcher = new AntPathMatcher();
        boolean match1 = matcher.match("/order/order/infoByOrderSn/**", requestURI);
        boolean match2 = matcher.match("/payed/**", requestURI);
        if (match1||match2) return true;

        HttpSession session = request.getSession();
        MemberResponseVo memberResponseVo = (MemberResponseVo) session.getAttribute(AuthServerConstant.LOGIN_USER);
        if (memberResponseVo != null) {
            loginUser.set(memberResponseVo);
            return true;
        }else {
            session.setAttribute("msg","请先登录");
            response.sendRedirect("http://auth.gulimall.com/login.html");
            return false;
        }
    
```





结合springsession实现





远程调用1





 支付- 订单

  购物车

  用户

  库存

  电商商品详细信息





提交订单

```c
    @RequestMapping("/submitOrder")
    public String submitOrder(OrderSubmitVo submitVo, Model model, RedirectAttributes attributes) {
        try{
            SubmitOrderResponseVo responseVo=orderService.submitOrder(submitVo);
            Integer code = responseVo.getCode();
            if (code==0){
                model.addAttribute("order", responseVo.getOrder());
                return "pay";
            }else {
                String msg = "下单失败;";
                switch (code) {
                    case 1:
                        msg += "防重令牌校验失败";
                        break;
                    case 2:
                        msg += "商品价格发生变化";
                        break;
                }
                attributes.addFlashAttribute("msg", msg);
                return "redirect:http://order.gulimall.com/toTrade";
            }
        }catch (Exception e){
            if (e instanceof NoStockException){
                String msg = "下单失败，商品无库存";
                attributes.addFlashAttribute("msg", msg);
            }
            return "redirect:http://order.gulimall.com/toTrade";
        }
    }

    /**
```



使用消息队列实现解耦处理



使用rocketTemplate实现



#### 异步回调机制



查看支付宝签名是否正确



```c
        boolean signVerified = AlipaySignature.rsaCheckV1(params, alipayTemplate.getAlipay_public_key(),
                alipayTemplate.getCharset(), alipayTemplate.getSign_type()); //调用SDK验证签名




        if (signVerified){
            System.out.println("支付宝异步通知验签成功");
            //修改订单状态
            orderService.handlerPayResult(payAsyncVo);
            return "success";
        }else {
            System.out.println("支付宝异步通知验签失败");
            return "error";
        }
    }
```



避免伪造签名

 未实际支付







#### 消息队列-rabbit 消息确认机制



```c
@RabbitHandler
public void createOrder(SeckillOrderTo orderTo, Message message, Channel channel) throws IOException {
    System.out.println("***********接收到秒杀消息");
    long deliveryTag = message.getMessageProperties().getDeliveryTag();
    try {
        orderService.createSeckillOrder(orderTo);
        channel.basicAck(deliveryTag, false);
    } catch (Exception e) {
        channel.basicReject(deliveryTag,true);
    }
```



兼容协议实现 JMS



#### ACK确认机制



#### （1）`channel.basicAck(deliveryTag, false)` —— 消息确认

- **底层含义**：向 RabbitMQ 发送「消息已成功消费」的确认，RabbitMQ 收到 ACK 后，会将该消息从队列中删除。

- **参数设计逻辑**：

  - `deliveryTag`：消息的唯一标识（每个 Channel 内自增的长整数），RabbitMQ 为每个推送给消费者的消息分配唯一 `deliveryTag`，用于区分不同消息（避免 ACK 错乱）；

  - ```
    multiple: false
    ```

  - 设计初衷：批量 ACK 可提升性能，但会降低可靠性（某条消息失败会导致批量消息无法重试），秒杀场景需精准控制，故用 `false`。



#### 关键底层组件：

- **Connection（连接）**：TCP 长连接，是 RabbitMQ 通信的基础，重量级资源（创建销毁耗性能），Spring AMQP 会通过 `ConnectionFactory` 管理连接池。
- **Channel（信道）**：轻量级通信通道，复用 Connection，所有消息操作（发布、消费、ACK）都通过 Channel 执行（避免多线程竞争 Connection）。代码中的 `Channel` 参数，就是当前消费操作对应的信道实例。
- **Consumer（消费者）**：Spring AMQP 会自动创建 `DefaultMessageListenerContainer`（消息监听容器），容器内部维护一个 `Consumer` 实例，负责从 RabbitMQ 拉取消息，并将消息转换后分发到 `@RabbitHandler` 方法。
- **消息转换**：默认通过 `SimpleMessageConverter` 将 RabbitMQ 的 `byte[]` 消息体，转换为业务对象 `SeckillOrderTo`（依赖 Jackson 序列化 / 反序列化）。



默认使用推模式实现

### . 配置 `prefetchCount` 控制消费速率（避免过载）

RabbitMQ 推模式下，默认会将队列中所有消息一次性推给消费者，若消费者处理速度慢，会导致消息堆积在消费者内存中，引发 OOM。

通过 `prefetchCount` 控制每次从 RabbitMQ 拉取的消息数量（底层通过 `basic.qos` 命令设置）





结合业务场景选择正确的api提供



### 2. 基于 `deliveryTag` 实现幂等消费（避免重复消息）

秒杀场景中，消息可能因「网络延迟」「重试」导致重复消费（如 ACK 发送成功但 RabbitMQ 未收到，会重新推送消息）。需结合 `deliveryTag` 或业务唯一标识实现幂等。





实现堵塞的处理ACK



假如使用回调函数



无法保证单个queue的消息有序性







---

课外延申机制



 小哈书





针对分页缓存机制

 jieheLUa脚本





订单

 订单项

```c
    //1. 创建订单
        OrderEntity orderEntity = new OrderEntity();
        orderEntity.setOrderSn(orderTo.getOrderSn());
        orderEntity.setMemberId(orderTo.getMemberId());
        if (memberResponseVo!=null){
            orderEntity.setMemberUsername(memberResponseVo.getUsername());
        }
        orderEntity.setStatus(OrderStatusEnum.CREATE_NEW.getCode());
        orderEntity.setCreateTime(new Date());
        orderEntity.setPayAmount(orderTo.getSeckillPrice().multiply(new BigDecimal(orderTo.getNum())));
        this.save(orderEntity);
        //2. 创建订单项
        R r = productFeignService.info(orderTo.getSkuId());
        if (r.getCode() == 0) {
            SeckillSkuInfoVo skuInfo = r.getData("skuInfo", new TypeReference<SeckillSkuInfoVo>() {
            });
            OrderItemEntity orderItemEntity = new OrderItemEntity();
            orderItemEntity.setOrderSn(orderTo.getOrderSn());
            orderItemEntity.setSpuId(skuInfo.getSpuId());
            orderItemEntity.setCategoryId(skuInfo.getCatalogId());
            orderItemEntity.setSkuId(skuInfo.getSkuId());
            orderItemEntity.setSkuName(skuInfo.getSkuName());
            orderItemEntity.setSkuPic(skuInfo.getSkuDefaultImg());
            orderItemEntity.setSkuPrice(skuInfo.getPrice());
            orderItemEntity.setSkuQuantity(orderTo.getNum());
            orderItemService.save(orderItemEntity);
        }
```





---

## 库存模块



验证是否存在库存机制



```c
    @Override
    public List<SkuHasStockVo> getSkuHasStocks(List<Long> ids) {
        List<SkuHasStockVo> skuHasStockVos = ids.stream().map(id -> {
            SkuHasStockVo skuHasStockVo = new SkuHasStockVo();
            skuHasStockVo.setSkuId(id);
            Integer count = baseMapper.getTotalStock(id);
            skuHasStockVo.setHasStock(count==null?false:count>0);
            return skuHasStockVo;
        }).collect(Collectors.toList());
        return skuHasStockVos;
    }

```





任务单机制

 -- 防止多个回滚失效



具体设计



```c
/**
 * 库存工作单
 * 
 * @author Ethan
 * @email hongshengmo@163.com
 * @date 2020-05-27 23:15:25
 */
@Data
@Builder
@TableName("wms_ware_order_task_detail")
public class WareOrderTaskDetailEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	/**
	 * id
	 */
	@TableId
	private Long id;
	/**
	 * sku_id
	 */
	private Long skuId;
	/**
	 * sku_name
	 */
	private String skuName;
	/**
	 * 购买个数
	 */
	private Integer skuNum;
	/**
	 * 工作单id
	 */
	private Long taskId;

	/**
	 * 仓库id
	 */
	private Long wareId;

	/**
	 * 锁定状态
	 */
	private Integer lockStatus;
}

```

```c

```



详细信息



```c
@Data
@TableName("wms_ware_order_task")
public class WareOrderTaskEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	/**
	 * id
	 */
	@TableId
	private Long id;
	/**
	 * order_id
	 */
	private Long orderId;
	/**
	 * order_sn
	 */
	private String orderSn;
	/**
	 * 收货人
	 */
```





针对一个订单中的库存



建立一个仓库中心 多区域



 首先查看最近的仓库



定时实时仓库信息 定时

 

 结合分配优先级进行分配



```c
   for (SkuLockVo lockVo : lockVos) {
            boolean lock = true;
            Long skuId = lockVo.getSkuId();
            List<Long> wareIds = lockVo.getWareIds();
            //如果没有满足条件的仓库，抛出异常
            if (wareIds == null || wareIds.size() == 0) {
                throw new NoStockException(skuId);
            }else {
                for (Long wareId : wareIds) {
                    Long count=baseMapper.lockWareSku(skuId, lockVo.getNum(), wareId);
                    if (count==0){
                        lock=false;
                    }else {
                        //锁定成功，保存工作单详情
                        WareOrderTaskDetailEntity detailEntity = WareOrderTaskDetailEntity.builder()
                                .skuId(skuId)
                                .skuName("")
                                .skuNum(lockVo.getNum())
                                .taskId(taskEntity.getId())
                                .wareId(wareId)
                                .lockStatus(1).build();
                        wareOrderTaskDetailService.save(detailEntity);
                        //发送库存锁定消息至延迟队列
                        StockLockedTo lockedTo = new StockLockedTo();
                        lockedTo.setId(taskEntity.getId());
                        StockDetailTo detailTo = new StockDetailTo();
                        BeanUtils.copyProperties(detailEntity,detailTo);
                        lockedTo.setDetailTo(detailTo);
                        rabbitTemplate.convertAndSend("stock-event-exchange","stock.locked",lockedTo);

                        lock = true;
                        break;
                    }
                }
```





执行sql语句

```c
    <update id="lockWareSku">
        UPDATE wms_ware_sku
        SET stock_locked=stock_locked+#{num}
        WHERE sku_id=#{skuId}
        AND ware_id=#{wareId}
        AND stock-stock_locked>#{num}
    </update>
        
```



实现具体仓库的sku库存锁定







定时任务

  取消失效订单的库存







----



## 搜索模块



```c
Configuration
public class GulimallElasticSearchConfig {
    @Bean
    public RestHighLevelClient restHighLevelClient() {
        RestHighLevelClient client = new RestHighLevelClient(
                RestClient.builder(
                        new HttpHost("192.168.56.102", 9200, "http"),
                        new HttpHost("192.168.56.102", 9201, "http")));
        return client;
    }


    public static final RequestOptions COMMON_OPTIONS;
    static {
        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();
//        builder.addHeader("Authorization", "Bearer " + TOKEN);
//        builder.setHttpAsyncResponseConsumerFactory(
//                new HttpAsyncResponseConsumerFactory
//                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));
        COMMON_OPTIONS = builder.build();
    }

}

```





构建es的配置处理



 使用默认链接处理





#### 构建es搜索请求结果处理



### 1. 解析「命中数据」：封装商品列表（`hits` 部分）

Es 的 `hits` 包含匹配的文档数组（`hits.getHits()`），每个文档是一个 `SearchHit`，核心存储 **文档原始数据（`_source`）** 和 **高亮信息（`highlight`）**（若查询时指定了高亮）。



假如使用聚合规则



###### -5. 解析「聚合结果」：品牌、分类、属性（核心难点）

查询时，Es 按预先定义的聚合规则（`brandAgg`、`catalogAgg`、`attrs` 等）计算统计结果，这里需要按聚合层级逐层解析。

#### 聚合规则回顾（查询时的定义逻辑）：

- 品牌聚合：先按 `brandId` 分组（`terms` 聚合），再在每组内聚合 `brandName`（品牌名）、`brandImg`（品牌图）；
- 分类聚合：按 `catalogId` 分组，再聚合 `catalogName`（分类名）；
- 属性聚合：先按 `attrs` 嵌套字段（属性是嵌套类型）聚合，再按 `attrId` 分组，最后聚合 `attrName`（属性名）和 `attrValue`（属性值）。



### 子聚合逻辑



```java
ParsedLongTerms brandAgg = aggregations.get("brandAgg");
// 2. 遍历每个品牌分组（Bucket）
for (Terms.Bucket bucket : brandAgg.getBuckets()) {
    Long brandId = bucket.getKeyAsNumber().longValue(); // 分组键 = 品牌ID
    // 3. 提取子聚合（品牌名、品牌图）
    Aggregations subBrandAggs = bucket.getAggregations();
    ParsedStringTerms brandImgAgg = subBrandAggs.get("brandImgAgg");
    String brandImg = brandImgAgg.getBuckets().get(0).getKeyAsString(); // 取第一个结果
    ParsedStringTerms brandNameAgg = subBrandAggs.get("brandNameAgg");
    String brandName = brandNameAgg.getBuckets().get(0).getKeyAsString();
    // 4. 封装为业务对象 BrandVo
    brandVos.add(new SearchResult.BrandVo(brandId, brandName, brandImg));
}
```



嵌套集合



#### 聚合解析核心规律：

| 聚合类型            | Es 结果接收类                                              | 解析关键操作                                                 |
| ------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 按字段分组（terms） | ParsedLongTerms（Long 型）/ ParsedStringTerms（String 型） | 遍历 `getBuckets()`，通过 `getKeyAsNumber()`/`getKeyAsString()` 获取分组键 |
| 嵌套聚合（nested）  | ParsedNested                                               | 先通过 `getAggregations()` 提取嵌套内的聚合，再逐层解析      |
| 子聚合              | 无固定类，依赖子聚合类型                                   | 每个 `Bucket` 都有 `getAggregations()`，可提取子聚合结果     |

```c
 //5 查询涉及到的所有属性
        List<SearchResult.AttrVo> attrVos = new ArrayList<>();
        //ParsedNested用于接收内置属性的聚合
        ParsedNested parsedNested=aggregations.get("attrs");
        ParsedLongTerms attrIdAgg=parsedNested.getAggregations().get("attrIdAgg");
        for (Terms.Bucket bucket : attrIdAgg.getBuckets()) {
            //5.1 查询属性id
            Long attrId = bucket.getKeyAsNumber().longValue();

            Aggregations subAttrAgg = bucket.getAggregations();
            //5.2 查询属性名
            ParsedStringTerms attrNameAgg=subAttrAgg.get("attrNameAgg");
            String attrName = attrNameAgg.getBuckets().get(0).getKeyAsString();
            //5.3 查询属性值
            ParsedStringTerms attrValueAgg = subAttrAgg.get("attrValueAgg");
            List<String> attrValues = new ArrayList<>();
            for (Terms.Bucket attrValueAggBucket : attrValueAgg.getBuckets()) {
                String attrValue = attrValueAggBucket.getKeyAsString();
                attrValues.add(attrValue);
                List<SearchResult.NavVo> navVos = new ArrayList<>();
            }
            SearchResult.AttrVo attrVo = new SearchResult.AttrVo(attrId, attrName, attrValues);
            attrVos.add(attrVo);
        }
        result.setAttrs(attrVos);

```



不同分组策略



 聚合内嵌属性





读取web请求和写入属性

```c
   @Bean
    public UrlBlockHandler urlBlockHandler() {
        return new UrlBlockHandler() {
            @Override
            public void blocked(HttpServletRequest request, HttpServletResponse response, BlockException ex) throws IOException {
                R r = R.error(BizCodeEnum.TO_MANY_REQUEST.getCode(), BizCodeEnum.TO_MANY_REQUEST.getMsg());
                response.setContentType("application/json;charset=utf-8");
                response.getWriter().write(JSON.toJSONString(r));
            }
        };
    }
```



---





## 针对产品模块



spu的规格参数

```c
  //4、保存spu的规格参数;pms_product_attr_value
        List<BaseAttrs> baseAttrs = spuSaveVo.getBaseAttrs();
        List<ProductAttrValueEntity> collect = baseAttrs.stream().map(attr -> {
            ProductAttrValueEntity entity = new ProductAttrValueEntity();
            entity.setSpuId(spuInfoEntity.getId());
            entity.setAttrId(attr.getAttrId());
            AttrEntity byId = attrService.getById(attr.getAttrId());
            entity.setAttrName(byId.getAttrName());
            entity.setAttrValue(attr.getAttrValues());
            entity.setQuickShow(attr.getShowDesc());
            return entity;
        }).collect(Collectors.toList());
        productAttrValueService.saveBatch(collect);
```





联系sku数据的录入

 



 且在保存spu新的 旗下的sku

  用于构建es文档





查看哪些属性用于构建attr



查看构建属性服务



```c

        List<Long> searchIds=attrService.selectSearchAttrIds(attrIds);


        Set<Long> ids = new HashSet<>(searchIds);

        
        List<SkuEsModel.Attr> searchAttrs = productAttrValueEntities.stream().filter(entity -> {
            return ids.contains(entity.getAttrId());
        }).map(entity -> {
            SkuEsModel.Attr attr = new SkuEsModel.Attr();
            BeanUtils.copyProperties(entity, attr);
            return attr;
        }).collect(Collectors.toList());
```



过滤出掉实际能构建model的搜索属性

 比如 具体内存规格 颜色





构建缓存机制



```c
        //缓存改写3：加锁解决缓存穿透问题
        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();
        String catalogJson = ops.get("catalogJson");
        if (StringUtils.isEmpty(catalogJson)) {
            System.out.println("缓存不命中，准备查询数据库。。。");
//            synchronized (this) {
//                String synCatalogJson = stringRedisTemplate.opsForValue().get("catalogJson");
//                if (StringUtils.isEmpty(synCatalogJson)) {
                    Map<String, List<Catalog2Vo>> categoriesDb= getCategoriesDb();
                    String toJSONString = JSON.toJSONString(categoriesDb);
                    ops.set("catalogJson", toJSONString);
                    return categoriesDb;
//                }else {
//                    Map<String, List<Catalog2Vo>> listMap = JSON.parseObject(synCatalogJson, new TypeReference<Map<String, List<Catalog2Vo>>>() {});
//                    return listMap;
//                }
//            }

        }
        System.out.println("缓存命中。。。。");
        Map<String, List<Catalog2Vo>> listMap = JSON.parseObject(catalogJson, new TypeReference<Map<String, List<Catalog2Vo>>>() {});
        return listMap;
    }
```



后续优化



 初步 当前使用DCL解决海量查询缓存



不命中 查询数据库



-- 





构建key





且设置一个过期时间



推荐使用二级缓存机制



构建一个布隆 判断缓存是否存在



-- 业务需求分析 针对需求进行系统和业务代码设计方案



先从代码中解析当前业务逻辑 且比较实际业务目标

优化技术方案实现 且先不进行代码设计实现



定时任务



--



多节点 -- 本地缓存不一致



商城的分类缓存全员共享



针对redis主从复制

 导致加入缓存失效



不设置过期时间

--



当缓存失效

  海量线程进入加锁逻辑

  是否堵塞

   不堵塞 tryLock

没有获取锁
  查看资源的是否得到
     不然返回旧数据 不要求一致性

不然抛出异常



业务设计优化





###### 优化设计



```c

        // 构建一个key

        // 获取key RLock 看门狗
        // 再次检查是否已更新缓存
        // 查询目标数据 构建缓存
        // 获取失败 直接返回1
        // 检查返回结果 是否未NUll 如果weinull 抛出异常
```



### . 非阻塞设计的业务价值落地

- 为什么不用 “阻塞锁”（如

   

  ```
  lock.lock()
  ```

  ）？

  - 海量线程阻塞时，会占用线程池资源，导致新请求无法处理（线程耗尽），系统吞吐量骤降；
  - 非阻塞设计下，线程要么 “快速拿到锁执行更新”，要么 “快速返回兜底数据”，响应时间可控（如 99% 请求在 100ms 内返回）；

- 取舍：牺牲 “部分请求拿到最新数据”，换取 “系统高可用 + 低延迟”，符合业务 “不要求一致性” 的前





-- 

若适用堵塞锁

  可以适用可重入锁的condtion机制



实现线程通信 根据实际的堵塞次数 累加失败获取次数 默认为3次



指的是看门狗在redisson具体api使用



超时时间 等待时间



tryLock



### 七、核心 API 总结（看门狗视角）

| 目标                   | 推荐 API                                                     | 看门狗状态 |
| ---------------------- | ------------------------------------------------------------ | ---------- |
| 自动续期的分布式锁     | `lock()` 或 `tryLock()`（无参）                              | 开启       |
| 固定过期时间的分布式锁 | `lock(leaseTime, unit)` 或 `tryLock(waitTime, leaseTime, unit)` | 关闭       |



是否指定过期时间

  实现看门狗机制



###### -- 提出疑问

  是否可以异步更新reids缓存



假如要达到某个条件之后

 提前更新缓存



--、针对场景适用



- 数据更新频率极高的场景（如每秒更新的实时统计）—— 缓存刚更新就失效，锁竞争频繁，方案收益低；
- 低并发场景（如后台管理系统）—— 无需复杂的锁机制，直接查 DB + 更新缓存即可。



--







使用hash分段加锁逻辑



##### 使用红锁处理 多节点 ！！！！


为何使用redLock

因为它只会存在于某一个Redis Master上，而Redis又不是基于CP模型的。那么就会有很大概率存在锁丢失的情况。以如下场景为例：1、线程T1在M1中加锁成功。





2、M1出现故障，但是由于主从同步延迟问题，加锁的KEY并没有同步到S1上。3、S1升级为Master节点。4、另一个线程T2在S1上也加锁成功，从而导致线程T1和T2都获取到了分布式锁。





单点故障导致同一把锁被加锁多次成功





而RedLock方法就是根除普通基于Redis分布式锁而生的（无论是主从模式、sentinel模式还是cluster模式）！官方把RedLock方法当作**使用Redis实现分布式锁的规范算法**，并认为这种实现比普通的单实例或者基于[Redis Cluster](https://zhida.zhihu.com/search?content_id=171403868&content_type=Article&match_order=1&q=Redis+Cluster&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjQ5Mjk2MTUsInEiOiJSZWRpcyBDbHVzdGVyIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTcxNDAzODY4LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.WlQgq8osTjZ6XT62SmFRygV3ZteQTenw0koEcdzedJ0&zhida_source=entity)的实现更安全。



###### redis集群模式



既然 RedLock 已经被废弃，那么想要实现分布式锁，同时又想避免 Redis 单点故障问题，应该使用哪种解决方案呢？

> 本文已收录到我的面试小站 [www.javacn.site](https://link.zhihu.com/?target=https%3A//www.javacn.site/)，其中包含的内容有：Redis、JVM、并发、并发、MySQL、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、设计模式、消息队列等模块。







---



#### 构建一个分类树形结构

```c
    public List<CategoryEntity> listWithTree() {
        List<CategoryEntity> entities = baseMapper.selectList(null);
        List<CategoryEntity> collect = entities.stream()
                .filter(item->item.getParentCid()==0)
                .map(menu->{
                    menu.setChildren(getChildrens(menu,entities));
                    return menu;
                })
                .sorted((menu1,menu2)->{
                    return (menu1.getSort()==null?0:menu1.getSort()) - (menu2.getSort()==null?0:menu2.getSort());
                })
                .collect(Collectors.toList());
        return collect;
    }
```





提取一级分类

 然后调用setchildren 

  设定该分类子类

​    优化递归机制





针对属性设置



```c
  AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrgroupId);
        Long catelogId = attrGroupEntity.getCatelogId();

        QueryWrapper<AttrEntity> wrapper=new QueryWrapper<AttrEntity>().eq("catelog_id", catelogId)
                //过滤掉销售属性
                .and((wrpper)->{
                    wrpper.eq("attr_type", 1);
                });
        //模糊搜索条件
        String key = (String) params.get("key");
        if(!StringUtils.isEmpty(key)){
            wrapper.and((w)->{
                w.eq("attr_id",key).or().like("attr_name",key);
            });
        }
        IPage<AttrEntity> page = this.page(
                new Query<AttrEntity>().getPage(params),wrapper);
        List<AttrEntity> records = page.getRecords();
```



构建查询语句 最终得到



属性实体列

  然后查看关联属性组



****

1. 运营输入 / 选择 “属性组 ID”（如 “手机 - 屏幕” 的 ID），系统先定位该属性组所属的 “手机” 分类 ——**贴合运营 “先选属性组，再找属性” 的操作路径**；



1. 只展示 “手机” 分类下的规格属性 ——**减少运营的无效筛选成本**，不用在成千上万个属性里手动排除无关项；
2. 再过滤已关联的属性 ——**最终只展示 “可操作的、相关的” 属性**，直接命中运营 “补充属性” 的核心







属性组 针对多个属性



```c
    @Override
    public List<AttrEntity> getRelationAttr(Long attrgroupId) {
        List<AttrAttrgroupRelationEntity> relationEntities = attrAttrgroupRelationDao.selectList(
                new QueryWrapper<AttrAttrgroupRelationEntity>().eq("attr_group_id", attrgroupId)
        );
        List<AttrEntity> attrEntities = relationEntities.stream().map((entity) -> {
            AttrEntity attrEntity = baseMapper.selectById(entity.getAttrId());
            return attrEntity;
        }).collect(Collectors.toList());
        return attrEntities;
    }
```



针对多对多关系







设置sku单元项



 使用并行计算



```c
    @Override
    public List<SkuInfoEntity> getSkusBySpuId(Long spuId) {
        List<SkuInfoEntity> skus = this.list(new QueryWrapper<SkuInfoEntity>().eq("spu_id", spuId));
        return skus;
    }

    SkuItemVo skuItemVo = new SkuItemVo();
        CompletableFuture<SkuInfoEntity> infoFuture = CompletableFuture.supplyAsync(() -> {
            //1、sku基本信息的获取  pms_sku_info
            SkuInfoEntity skuInfoEntity = this.getById(skuId);
            skuItemVo.setInfo(skuInfoEntity);
            return skuInfoEntity;
        }, executor);

 \
        //2、sku的图片信息    pms_sku_images
        CompletableFuture<Void> imageFuture = CompletableFuture.runAsync(() -> {
            List<SkuImagesEntity> skuImagesEntities = skuImagesService.list(new QueryWrapper<SkuImagesEntity>().eq("sku_id", skuId));
            skuItemVo.setImages(skuImagesEntities);
        }, executor);

```



首先使用supply 获取查询构建并行基本信息

  runAsync 该api 用于开启任务 用于设定返回参数

  然后使用info的构建号。利用accept 结合之前返回结果进一步处理



  若是消费 不会拿到前面运行结果









## 消费卷模块



实际简单设计i 、

  没有实际包含特定优惠卷负责场景





单独联调支付模块和订单模块





结合购物车skuid



且结合该用户的优惠卷列表



 得到合适的优惠卷结算chuli



由订单远程调用



商品的总结 或者查询待支付订单



然后得到订单单元项 且单独计算总价



优先顺序 -- 优惠最大金额



且是否可以叠加处理



或者由用户手动指定



---





## 秒杀模块

针对redis的key特殊设计



存放redis优惠卷完全体





```c
  @Override
    public String kill(String killId, String key, Integer num) throws InterruptedException {
        BoundHashOperations<String, String, String> ops = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);
        String json = ops.get(killId);
        String orderSn = null;
        if (!StringUtils.isEmpty(json)){
            SeckillSkuRedisTo redisTo = JSON.parseObject(json, SeckillSkuRedisTo.class);
            //1. 验证时效
            long current = System.currentTimeMillis();
            if (current >= redisTo.getStartTime() && current <= redisTo.getEndTime()) {
                //2. 验证商品和商品随机码是否对应
                String redisKey = redisTo.getPromotionSessionId() + "-" + redisTo.getSkuId();
                if (redisKey.equals(killId) && redisTo.getRandomCode().equals(key)) {
                    //3. 验证当前用户是否购买过
                    MemberResponseVo memberResponseVo = LoginInterceptor.loginUser.get();
                    long ttl = redisTo.getEndTime() - System.currentTimeMillis();
                    //3.1 通过在redis中使用 用户id-skuId 来占位看是否买过
                    Boolean occupy = redisTemplate.opsForValue().setIfAbsent(memberResponseVo.getId()+"-"+redisTo.getSkuId(), num.toString(), ttl, TimeUnit.MILLISECONDS);
                    //3.2 占位成功，说明该用户未秒杀过该商品，则继续
                    if (occupy){
```



查询现在秒杀场景



使用hash 保存具体秒杀sku实体



然后hash key 具体的时间+ skuid





同时判断客户是否购买秒伤商品



根据具体 用户+sku+会话时间

过期时间 根据具体会话结束实现o



且设定秒杀具体sku的库存设置



使用sku stock 



代实现



 使用信号量机制



  实现库存机制







获取指定reid范围内的商品数目



| `redisTemplate.keys(SESSION_CACHE_PREFIX + "*")`          | 从 Redis 中获取所有秒杀场次的 Key        | 得到 Redis Key 列表：`seckill:session:1749907200000_1749910800000`（第一场：00:00-01:00）`seckill:session:1749910800000_1749914400000`（第二场：01:00-02:00）`seckill:session:1749914400000_1749918000000`（第三场：02:00-03:00）（注：数字为时间戳，对应秒杀开始 / 结束时间） |
| --------------------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| `key.replace(SESSION_CACHE_PREFIX, "")` + `split("_")`    | 解析每个场次 Key 的开始 / 结束时间戳     | 解析第一场 Key 得到：startTime=1749907200000（00:00）、endTime=1749910800000（01:00）；第二场 startTime=1749910800000（01:00）、endTime=1749914400000（02:00）；第三场同理。 |
| `currentTime > startTime && currentTime < endTime`        | 判断当前时间是否在秒杀场次有效期内       | 当前时间戳 = 1749909000000（00:30），仅第一场满足条件（00:00 < 00:30 < 01:00），其余场次不满足。 |
| `redisTemplate.opsForList().range(key, -100, 100)`        | 获取当前有效场次下的秒杀商品 ID 列表     | 从第一场的 Redis List 中获取商品 ID：`["1001"（iPhone 15）, "1002"（华为Mate 60 Pro）]` |
| `redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX).get(s)` | 根据商品 ID 从 Redis Hash 中获取商品详情 | 从 Hash（key=seckill:cache）中获取：ID=1001 → 详情 JSON：`{"skuId":1001,"skuName":"iPhone 15 128G","seckillPrice":4999,"stockCount":100,...}`ID=1002 → 详情 JSON：`{"skuId":1002,"skuName":"华为Mate 60 Pro","seckillPrice":5999,"stockCount":50,...}` |







若消除指定的秒杀商品



  @Override

  public String kill(String killId, String key, Integer num) throw





```mermaid
graph TD
    A["开始"] --> B["获取Redis中秒杀商品信息<br/>（根据killId从SECKILL_CHARE_PREFIX Hash中查json）"]
    B --> C{"商品信息是否为空？<br/>(json.isEmpty())"}
    C -- 是 --> Z["结束<br/>返回null"]
    C -- 否 --> D["解析json为SeckillSkuRedisTo对象"]
    D --> E{"验证秒杀时效<br/>(当前时间是否在startTime-endTime之间)"}
    E -- 否 --> Z
    E -- 是 --> F{"验证商品标识&随机码<br/>(killId=promotionSessionId-skuId？<br/>key=randomCode？)"}
    F -- 否 --> Z
    F -- 是 --> G["获取当前登录用户信息<br/>(LoginInterceptor.loginUser.get())"]
    G --> H["生成用户-商品唯一标识<br/>(userId-skuId)"]
    H --> I["Redis占位校验是否已购买<br/>(setIfAbsent(userId-skuId, num, 剩余时效))"]
    I --> J{"占位是否成功？<br/>(occupy=true？)"}
    J -- 否 --> Z["结束<br/>返回null（用户已购买）"]
    J -- 是 --> K{"验证购买数量<br/>(num ≤ seckillLimit？)"}
    K -- 否 --> Z
    K -- 是 --> L["获取库存信号量<br/>(Redisson Semaphore：SKU_STOCK_SEMAPHORE+randomCode)"]
    L --> M{"尝试获取库存许可<br/>(tryAcquire(num, 100ms))"}
    M -- 失败 --> Z["结束<br/>返回null（库存不足/超时）"]
    M -- 成功 --> N["生成订单编号orderSn<br/>(IdWorker.getTimeId())"]
    N --> O["构建SeckillOrderTo对象<br/>(封装用户/商品/数量/价格等信息)"]
    O --> P["发送创建订单消息<br/>(MQ：order-event-exchange → order.seckill.order)"]
    P --> Q["结束<br/>返回orderSn（订单编号）"]
```





信号量机制i



#### 3. 代码中信号量设计的额外价值

代码中`semaphore.tryAcquire(num,100,TimeUnit.MILLISECONDS)`的设计，除了控库存，还实现了：

- **超时保护**：100ms 内未抢到库存则放弃，避免请求长时间阻塞，提升系统吞吐量；
- **批量扣减**：支持`num`（购买数量）的批量校验，适配 “限购 N 件” 的业务规则；
- **非阻塞获取**：`tryAcquire`是非阻塞的，相比`acquire`（阻塞）更适配秒杀 “抢不到就快速返回” 的用户体验



在保存秒杀sku同时实现



允许具体信号量机制



```c
 private void saveSecKillSku(List<SeckillSessionWithSkusVo> sessions) {
        BoundHashOperations<String, Object, Object> ops = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);
        sessions.stream().forEach(session->{
            session.getRelations().stream().forEach(sku->{
                String key = sku.getPromotionSessionId() +"-"+ sku.getSkuId();
                if (!ops.hasKey(key)){
                    SeckillSkuRedisTo redisTo = new SeckillSkuRedisTo();
                    //1. 保存SeckillSkuVo信息
                    BeanUtils.copyProperties(sku,redisTo);
                    //2. 保存开始结束时间
                    redisTo.setStartTime(session.getStartTime().getTime());
                    redisTo.setEndTime(session.getEndTime().getTime());
                    //3. 远程查询sku信息并保存
                    R r = productFeignService.info(sku.getSkuId());
                    if (r.getCode() == 0) {
                        SkuInfoVo skuInfo = r.getData("skuInfo", new TypeReference<SkuInfoVo>() {
                        });
                        redisTo.setSkuInfoVo(skuInfo);
                    }
                    //4. 生成商品随机码，防止恶意攻击
                    String token = UUID.randomUUID().toString().replace("-", "");
                    redisTo.setRandomCode(token);
                    //5. 序列化为json并保存
                    String jsonString = JSON.toJSONString(redisTo);
                    ops.put(key,jsonString);
                    //5. 使用库存作为Redisson信号量限制库存
                    RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);
                    semaphore.trySetPermits(sku.getSeckillCount());
                }
            });
        });
```

